<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JettyHttpClient.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagontk.http.client.jetty</a> &gt; <span class="el_source">JettyHttpClient.kt</span></div><h1>JettyHttpClient.kt</h1><pre class="source lang-java linenums">package com.hexagontk.http.client.jetty

import com.hexagontk.core.media.TEXT_EVENT_STREAM
import com.hexagontk.core.security.loadKeyStore
import com.hexagontk.http.handlers.bodyToBytes
import com.hexagontk.http.HttpFeature
import com.hexagontk.http.HttpFeature.*
import com.hexagontk.http.client.HttpClient
import com.hexagontk.http.client.HttpClientPort
import com.hexagontk.http.client.HttpClientSettings
import com.hexagontk.http.model.HttpResponse
import com.hexagontk.http.model.*
import com.hexagontk.http.model.CookieSameSite.*
import com.hexagontk.http.model.HttpProtocol.HTTP
import com.hexagontk.http.model.HttpProtocol.HTTPS
import com.hexagontk.http.model.ws.WsSession
import com.hexagontk.http.parseContentType
import org.eclipse.jetty.client.HttpResponseException
import org.eclipse.jetty.client.ContentResponse
import org.eclipse.jetty.client.Request
import org.eclipse.jetty.client.Response
import org.eclipse.jetty.client.transport.HttpClientTransportDynamic
import org.eclipse.jetty.client.transport.HttpClientConnectionFactory.HTTP11
import org.eclipse.jetty.client.BytesRequestContent
import org.eclipse.jetty.client.MultiPartRequestContent
import org.eclipse.jetty.client.StringRequestContent
import org.eclipse.jetty.http.HttpCookie
import org.eclipse.jetty.http.HttpCookie.SameSite
import org.eclipse.jetty.http.HttpCookieStore
import org.eclipse.jetty.http.HttpFields as JettyHttpFields
import org.eclipse.jetty.http.HttpFields.EMPTY
import org.eclipse.jetty.http.HttpMethod
import org.eclipse.jetty.http.MultiPart.ContentSourcePart
import org.eclipse.jetty.io.ClientConnector
import java.lang.StringBuilder
import java.lang.UnsupportedOperationException
import java.net.URI
import java.util.concurrent.ExecutionException
import java.util.concurrent.Executors
import java.util.concurrent.Flow.Publisher
import java.util.concurrent.SubmissionPublisher
import org.eclipse.jetty.http2.client.HTTP2Client as JettyHttp2Client
import org.eclipse.jetty.http2.client.transport.ClientConnectionFactoryOverHTTP2.HTTP2
import org.eclipse.jetty.client.HttpClient as JettyClient
import org.eclipse.jetty.util.ssl.SslContextFactory.Client as ClientSslContextFactory

/**
 * Client to use other REST services.
 */
<span class="fc" id="L50">open class JettyHttpClient : HttpClientPort {</span>

<span class="fc" id="L52">    protected lateinit var jettyClient: JettyClient</span>
<span class="fc" id="L53">    protected lateinit var httpClient: HttpClient</span>
    private lateinit var httpSettings: HttpClientSettings
    private var started: Boolean = false
<span class="fc" id="L56">    private val publisherExecutor = Executors.newSingleThreadExecutor()</span>

    override fun startUp(client: HttpClient) {
<span class="fc" id="L59">        val clientConnector = ClientConnector()</span>
<span class="fc" id="L60">        val settings = client.settings</span>
<span class="fc" id="L61">        clientConnector.sslContextFactory = sslContext(settings)</span>

<span class="fc" id="L63">        val http2 = HTTP2(JettyHttp2Client(clientConnector))</span>
<span class="fc" id="L64">        val transport = HttpClientTransportDynamic(clientConnector, HTTP11, http2)</span>

<span class="fc" id="L66">        jettyClient = JettyClient(transport)</span>
<span class="fc" id="L67">        httpClient = client</span>
<span class="fc" id="L68">        httpSettings = settings</span>

<span class="fc" id="L70">        jettyClient.userAgentField = null // Disable default user agent header</span>
<span class="fc" id="L71">        jettyClient.isFollowRedirects = settings.followRedirects</span>
<span class="fc" id="L72">        jettyClient.start()</span>
<span class="fc" id="L73">        started = true</span>
<span class="fc" id="L74">    }</span>

    override fun shutDown() {
<span class="fc" id="L77">        jettyClient.stop()</span>
<span class="fc" id="L78">        started = false</span>
<span class="fc" id="L79">    }</span>

    override fun started() =
<span class="fc" id="L82">        started</span>

    override fun send(request: HttpRequestPort): HttpResponsePort {
<span class="fc" id="L85">        val response =</span>
<span class="fc" id="L86">            try {</span>
<span class="fc" id="L87">                createJettyRequest(jettyClient, request).send()</span>
            }
<span class="fc" id="L89">            catch (e: ExecutionException) {</span>
<span class="fc" id="L90">                val cause = e.cause</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (cause is HttpResponseException) cause.response</span>
<span class="fc" id="L92">                else throw e</span>
            }

<span class="fc" id="L95">        return convertJettyResponse(httpClient, jettyClient, response)</span>
    }

    override fun ws(
        path: String,
        onConnect: WsSession.() -&gt; Unit,
        onBinary: WsSession.(data: ByteArray) -&gt; Unit,
        onText: WsSession.(text: String) -&gt; Unit,
        onPing: WsSession.(data: ByteArray) -&gt; Unit,
        onPong: WsSession.(data: ByteArray) -&gt; Unit,
        onClose: WsSession.(status: Int, reason: String) -&gt; Unit,
    ): WsSession {
<span class="nc" id="L107">        throw UnsupportedOperationException(&quot;WebSockets not supported. Use 'http_client_jetty_ws&quot;)</span>
    }

    override fun sse(request: HttpRequestPort): Publisher&lt;ServerEvent&gt; {
<span class="fc" id="L111">        val clientPublisher = SubmissionPublisher&lt;ServerEvent&gt;(publisherExecutor, Int.MAX_VALUE)</span>

<span class="fc" id="L113">        val sseRequest = request.with(</span>
<span class="fc" id="L114">            accept = listOf(ContentType(TEXT_EVENT_STREAM)),</span>
<span class="fc" id="L115">            headers = request.headers + Field(&quot;connection&quot;, &quot;keep-alive&quot;)</span>
        )

<span class="fc" id="L118">        createJettyRequest(jettyClient, sseRequest)</span>
<span class="fc" id="L119">            .onResponseBegin {</span>
<span class="pc bpc" id="L120" title="3 of 6 branches missed.">                if (it.status !in 200 until 300)</span>
<span class="nc" id="L121">                    error(&quot;Invalid response: ${it.status}&quot;)</span>
<span class="fc" id="L122">            }</span>
<span class="fc" id="L123">            .onResponseContent { _, content -&gt;</span>
<span class="fc" id="L124">                val sb = StringBuilder()</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                while (content.hasRemaining())</span>
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">                    sb.append(Char(content.get().toInt()))</span>

<span class="fc" id="L128">                val evt = sb</span>
<span class="fc" id="L129">                    .trim()</span>
<span class="fc" id="L130">                    .lines()</span>
<span class="fc" id="L131">                    .map { it.split(&quot;:&quot;) }</span>
<span class="fc" id="L132">                    .associate { it.first().trim().lowercase() to it.last().trim() }</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">                    .let { ServerEvent(it[&quot;event&quot;], it[&quot;data&quot;], it[&quot;id&quot;], it[&quot;retry&quot;]?.toLong()) }</span>

<span class="fc" id="L135">                clientPublisher.submit(evt)</span>
<span class="fc" id="L136">            }</span>
<span class="fc" id="L137">            .send {</span>
<span class="fc" id="L138">                clientPublisher.close()</span>
<span class="fc" id="L139">            }</span>

<span class="fc" id="L141">        return clientPublisher</span>
    }

    override fun supportedFeatures(): Set&lt;HttpFeature&gt; =
<span class="nc" id="L145">        setOf(ZIP, COOKIES, MULTIPART, SSE)</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="nc" id="L148">        setOf(HTTP, HTTPS, HttpProtocol.HTTP2)</span>

    private fun convertJettyResponse(
        adapterHttpClient: HttpClient, adapterJettyClient: JettyClient, response: Response
    ): HttpResponse {

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        val bodyString = if (response is ContentResponse) response.contentAsString else &quot;&quot;</span>

<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (httpSettings.useCookies)</span>
<span class="fc" id="L157">            adapterHttpClient.cookies = adapterJettyClient.httpCookieStore.all().map {</span>
<span class="fc" id="L158">                Cookie(</span>
<span class="fc" id="L159">                    it.name,</span>
<span class="fc" id="L160">                    it.value,</span>
<span class="fc" id="L161">                    it.maxAge,</span>
<span class="fc" id="L162">                    it.isSecure,</span>
<span class="fc" id="L163">                    it.path,</span>
<span class="fc" id="L164">                    it.isHttpOnly,</span>
<span class="fc" id="L165">                    it.domain,</span>
<span class="pc bpc" id="L166" title="3 of 4 branches missed.">                    it.attributes[&quot;SameSite&quot;]?.uppercase()?.let(CookieSameSite::valueOf),</span>
<span class="fc" id="L167">                    expires = it.expires,</span>
<span class="fc" id="L168">                )</span>
            }

<span class="fc" id="L171">        return HttpResponse(</span>
<span class="fc" id="L172">            body = bodyString,</span>
<span class="fc" id="L173">            headers = convertHeaders(response.headers),</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            contentType = response.headers[&quot;content-type&quot;]?.let { parseContentType(it) },</span>
<span class="fc" id="L175">            cookies = adapterHttpClient.cookies,</span>
<span class="fc" id="L176">            status = response.status,</span>
<span class="fc" id="L177">            contentLength = bodyString.length.toLong(),</span>
        )
    }

    private fun convertHeaders(headers: JettyHttpFields): Headers =
<span class="fc" id="L182">        Headers(</span>
<span class="fc" id="L183">            headers</span>
<span class="fc" id="L184">                .fieldNamesCollection</span>
<span class="fc" id="L185">                .map { it.lowercase() }</span>
<span class="fc" id="L186">                .flatMap { h -&gt; headers.getValuesList(h).map { Field(h, it) } }</span>
<span class="fc" id="L187">        )</span>

    private fun createJettyRequest(
        adapterJettyClient: JettyClient, request: HttpRequestPort
    ): Request {

        // TODO Remove these fields and handle them as headers
<span class="fc" id="L194">        val contentType = request.contentType</span>
<span class="fc" id="L195">        val authorization = request.authorization</span>
<span class="fc" id="L196">        val baseUrl = httpSettings.baseUrl</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (httpSettings.useCookies) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            val uri = (baseUrl ?: request.url()).toURI()</span>
<span class="fc" id="L200">            addCookies(uri, adapterJettyClient.httpCookieStore, request.cookies)</span>
        }

<span class="fc" id="L203">        val jettyRequest = adapterJettyClient</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">            .newRequest(URI((baseUrl?.toString() ?: &quot;&quot;) + request.path))</span>
<span class="fc" id="L205">            .method(HttpMethod.valueOf(request.method.toString()))</span>
<span class="fc" id="L206">            .headers {</span>
<span class="fc" id="L207">                it.remove(&quot;accept-encoding&quot;) // Don't send encoding by default</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                if (contentType != null)</span>
<span class="fc" id="L209">                    it.put(&quot;content-type&quot;, contentType.text)</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                if (authorization != null)</span>
<span class="fc" id="L211">                    it.put(&quot;authorization&quot;, authorization.text)</span>
<span class="fc" id="L212">                request.headers.all.forEach { (k, v) -&gt;</span>
<span class="fc" id="L213">                    v.map(HttpField::text).forEach { s -&gt; it.add(k, s)}</span>
<span class="fc" id="L214">                }</span>
<span class="fc" id="L215">            }</span>
<span class="fc" id="L216">            .body(createBody(request))</span>
<span class="fc" id="L217">            .accept(*request.accept.map { it.text }.toTypedArray())</span>

<span class="fc" id="L219">        request.queryParameters.all</span>
<span class="fc" id="L220">            .forEach { (k, v) -&gt; v.forEach { jettyRequest.param(k, it.text) } }</span>

<span class="fc" id="L222">        return jettyRequest</span>
    }

    private fun createBody(request: HttpRequestPort): Request.Content {

<span class="fc bfc" id="L227" title="All 4 branches covered.">        if (request.parts.isEmpty() &amp;&amp; request.formParameters.isEmpty())</span>
<span class="fc" id="L228">            return BytesRequestContent(bodyToBytes(request.body))</span>

<span class="fc" id="L230">        val multiPart = MultiPartRequestContent()</span>

<span class="fc" id="L232">        request.parts.forEach { p -&gt;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            if (p.submittedFileName == null)</span>
                // TODO Add content type if present
<span class="fc" id="L235">                multiPart.addPart(</span>
<span class="fc" id="L236">                    ContentSourcePart(p.name, null, EMPTY, StringRequestContent(p.bodyString()))</span>
                )
            else
<span class="fc" id="L239">                multiPart.addPart(</span>
<span class="fc" id="L240">                    ContentSourcePart(</span>
<span class="fc" id="L241">                        p.name,</span>
<span class="fc" id="L242">                        p.submittedFileName,</span>
<span class="fc" id="L243">                        EMPTY,</span>
<span class="fc" id="L244">                        BytesRequestContent(bodyToBytes(p.body)),</span>
                    )
                )
<span class="fc" id="L247">        }</span>

<span class="fc" id="L249">        request.formParameters.fields.forEach {</span>
<span class="fc" id="L250">            val part = ContentSourcePart(it.name, null, EMPTY, StringRequestContent(it.text))</span>
<span class="fc" id="L251">            multiPart.addPart(part)</span>
<span class="fc" id="L252">        }</span>

<span class="fc" id="L254">        multiPart.close()</span>

<span class="fc" id="L256">        return multiPart</span>
    }

    private fun addCookies(uri: URI, store: HttpCookieStore, cookies: List&lt;Cookie&gt;) {
<span class="fc" id="L260">        cookies.forEach {</span>
<span class="fc" id="L261">            val httpCookie = java.net.HttpCookie(it.name, it.value)</span>
<span class="fc" id="L262">            httpCookie.secure = it.secure</span>
<span class="fc" id="L263">            httpCookie.maxAge = it.maxAge</span>
<span class="fc" id="L264">            httpCookie.path = it.path</span>
<span class="fc" id="L265">            httpCookie.isHttpOnly = it.httpOnly</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            it.domain?.let(httpCookie::setDomain)</span>

<span class="fc" id="L268">            val from = HttpCookie.build(httpCookie).expires(it.expires)</span>

<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            it.sameSite?.let { ss -&gt;</span>
<span class="nc bnc" id="L271" title="All 3 branches missed.">                when(ss){</span>
<span class="nc" id="L272">                    STRICT -&gt; SameSite.STRICT</span>
<span class="nc" id="L273">                    LAX -&gt; SameSite.LAX</span>
<span class="nc" id="L274">                    NONE -&gt; SameSite.NONE</span>
<span class="nc" id="L275">                }</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            }?.let { ss -&gt; from.sameSite(ss) }</span>

<span class="fc" id="L278">            store.add(uri, from.build())</span>
<span class="fc" id="L279">        }</span>
<span class="fc" id="L280">    }</span>

    private fun sslContext(settings: HttpClientSettings): ClientSslContextFactory =
<span class="fc" id="L283">        when {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            settings.insecure -&gt;</span>
<span class="fc" id="L285">                ClientSslContextFactory().apply { isTrustAll = true }</span>

<span class="fc bfc" id="L287" title="All 2 branches covered.">            settings.sslSettings != null -&gt; {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">                val sslSettings = settings.sslSettings ?: error(&quot;SSL settings cannot be 'null'&quot;)</span>
<span class="fc" id="L289">                val keyStore = sslSettings.keyStore</span>
<span class="fc" id="L290">                val trustStore = sslSettings.trustStore</span>
<span class="fc" id="L291">                val sslContextBuilder = ClientSslContextFactory()</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">                if (keyStore != null) {</span>
<span class="fc" id="L294">                    val store = loadKeyStore(keyStore, sslSettings.keyStorePassword)</span>
<span class="fc" id="L295">                    sslContextBuilder.keyStore = store</span>
<span class="fc" id="L296">                    sslContextBuilder.keyStorePassword = sslSettings.keyStorePassword</span>
                }

<span class="fc bfc" id="L299" title="All 2 branches covered.">                if (trustStore != null) {</span>
<span class="fc" id="L300">                    val store = loadKeyStore(trustStore, sslSettings.trustStorePassword)</span>
<span class="fc" id="L301">                    sslContextBuilder.trustStore = store</span>
<span class="fc" id="L302">                    sslContextBuilder.setTrustStorePassword(sslSettings.trustStorePassword)</span>
                }

<span class="fc" id="L305">                sslContextBuilder</span>
            }

            else -&gt;
<span class="fc" id="L309">                ClientSslContextFactory()</span>
<span class="fc" id="L310">        }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>