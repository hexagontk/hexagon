<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JdkHttpClient.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagontk.http.client.jdk</a> &gt; <span class="el_source">JdkHttpClient.kt</span></div><h1>JdkHttpClient.kt</h1><pre class="source lang-java linenums">package com.hexagontk.http.client.jdk

import com.hexagontk.core.security.createKeyManagerFactory
import com.hexagontk.core.security.createTrustManagerFactory
import com.hexagontk.http.*
import com.hexagontk.http.HttpFeature.*
import com.hexagontk.http.client.HttpClient
import com.hexagontk.http.client.HttpClientPort
import com.hexagontk.http.client.HttpClientSettings
import com.hexagontk.http.handlers.bodyToBytes
import com.hexagontk.http.model.*
import com.hexagontk.http.model.HttpProtocol.*
import com.hexagontk.http.model.HttpResponse
import com.hexagontk.http.model.ws.WsSession
import java.net.CookieManager
import java.net.HttpCookie
import java.net.URI
import java.net.http.HttpClient.Redirect.ALWAYS
import java.net.http.HttpClient.Redirect.NEVER
import java.net.http.HttpClient.Version.HTTP_1_1
import java.net.http.HttpClient.Version.HTTP_2
import java.net.http.HttpHeaders
import java.net.http.HttpRequest.BodyPublishers
import java.net.http.HttpResponse.BodyHandlers
import java.security.SecureRandom
import java.security.cert.X509Certificate
import java.util.concurrent.Executor
import java.util.concurrent.Flow.Publisher
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManagerFactory
import javax.net.ssl.X509TrustManager
import java.net.http.HttpClient as JavaClient
import java.net.http.HttpRequest as JavaHttpRequest
import java.net.http.HttpResponse as JavaHttpResponse

/**
 * Client to use other REST services.
 */
<span class="pc" id="L40">class JdkHttpClient(</span>
<span class="pc" id="L41">    private val protocol: HttpProtocol = HTTP2,</span>
<span class="pc" id="L42">    private val executor: Executor? = null,</span>
<span class="nc" id="L43">) : HttpClientPort {</span>

    private companion object {
        object TrustAll : X509TrustManager {
            override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt; =
<span class="fc" id="L48">                emptyArray()</span>

<span class="nc" id="L50">            override fun checkClientTrusted(certs: Array&lt;X509Certificate&gt;, authType: String) {}</span>

<span class="fc" id="L52">            override fun checkServerTrusted(certs: Array&lt;X509Certificate&gt;, authType: String) {}</span>
        }
    }

    private lateinit var javaClient: JavaClient
    private lateinit var httpClient: HttpClient
    private lateinit var httpSettings: HttpClientSettings
    private var started: Boolean = false
<span class="fc" id="L60">    private val cookieManager: CookieManager by lazy { CookieManager() }</span>

<span class="fc" id="L62">    constructor() : this(HTTP2, null)</span>

    override fun startUp(client: HttpClient) {
<span class="fc" id="L65">        val settings = client.settings</span>

<span class="fc" id="L67">        httpClient = client</span>
<span class="fc" id="L68">        httpSettings = settings</span>
<span class="fc" id="L69">        val javaClientBuilder = JavaClient</span>
<span class="fc" id="L70">            .newBuilder()</span>
<span class="pc bpc" id="L71" title="3 of 4 branches missed.">            .version(if (protocol == HTTP2 || protocol == H2C) HTTP_2 else HTTP_1_1)</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            .followRedirects(if (settings.followRedirects) ALWAYS else NEVER)</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (settings.useCookies)</span>
<span class="fc" id="L75">            javaClientBuilder.cookieHandler(cookieManager)</span>

<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (executor != null)</span>
<span class="nc" id="L78">            javaClientBuilder.executor(executor)</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">        settings.sslSettings?.let { javaClientBuilder.sslContext(sslContext(it)) }</span>

<span class="fc" id="L82">        javaClient = javaClientBuilder.build()</span>

<span class="fc" id="L84">        started = true</span>
<span class="fc" id="L85">    }</span>

    override fun shutDown() {
<span class="fc" id="L88">        started = false</span>
<span class="fc" id="L89">    }</span>

    override fun started() =
<span class="fc" id="L92">        started</span>

    override fun send(request: HttpRequestPort): HttpResponsePort {
<span class="fc" id="L95">        val hexagonRequest = createRequest(request)</span>
<span class="fc" id="L96">        val javaResponse = javaClient.send(hexagonRequest, BodyHandlers.ofByteArray())</span>
<span class="fc" id="L97">        return convertResponse(javaResponse)</span>
    }

    override fun ws(
        path: String,
        onConnect: WsSession.() -&gt; Unit,
        onBinary: WsSession.(data: ByteArray) -&gt; Unit,
        onText: WsSession.(text: String) -&gt; Unit,
        onPing: WsSession.(data: ByteArray) -&gt; Unit,
        onPong: WsSession.(data: ByteArray) -&gt; Unit,
        onClose: WsSession.(status: Int, reason: String) -&gt; Unit,
    ): WsSession {
<span class="nc" id="L109">        throw UnsupportedOperationException(&quot;WebSockets not supported&quot;)</span>
    }

    override fun sse(request: HttpRequestPort): Publisher&lt;ServerEvent&gt; {
<span class="nc" id="L113">        throw UnsupportedOperationException(&quot;SSE not supported&quot;)</span>
    }

    override fun supportedFeatures(): Set&lt;HttpFeature&gt; =
<span class="nc" id="L117">        setOf(ZIP, COOKIES)</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="nc" id="L120">        setOf(HTTP, HTTPS, HTTP2, H2C)</span>

    private fun sslContext(sslSettings: SslSettings): SSLContext {
<span class="fc" id="L123">        val sslContext = SSLContext.getInstance(&quot;TLSv1.3&quot;)</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (httpSettings.insecure)</span>
<span class="fc" id="L126">            return sslContext.apply {</span>
<span class="fc" id="L127">                init(emptyArray(), arrayOf(TrustAll), SecureRandom.getInstanceStrong())</span>
<span class="fc" id="L128">            }</span>

<span class="fc" id="L130">        val keyManager = keyManagerFactory(sslSettings)</span>
<span class="fc" id="L131">        val trustManager = trustManagerFactory(sslSettings)</span>
<span class="fc" id="L132">        return sslContext.apply {</span>
<span class="fc" id="L133">            init(</span>
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">                keyManager?.keyManagers ?: emptyArray(),</span>
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">                trustManager?.trustManagers ?: emptyArray(),</span>
<span class="fc" id="L136">                SecureRandom.getInstanceStrong()</span>
            )
<span class="fc" id="L138">        }</span>
    }

    private fun trustManagerFactory(sslSettings: SslSettings): TrustManagerFactory? {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        val trustStoreUrl = sslSettings.trustStore ?: return null</span>
<span class="fc" id="L143">        val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L144">        return createTrustManagerFactory(trustStoreUrl, trustStorePassword)</span>
    }

    private fun keyManagerFactory(sslSettings: SslSettings): KeyManagerFactory? {
<span class="fc bfc" id="L148" title="All 2 branches covered.">        val keyStoreUrl = sslSettings.keyStore ?: return null</span>
<span class="fc" id="L149">        val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L150">        return createKeyManagerFactory(keyStoreUrl, keyStorePassword)</span>
    }

    private fun createRequest(request: HttpRequestPort): JavaHttpRequest {
<span class="fc" id="L154">        val baseUri = httpSettings.baseUri</span>

<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (httpSettings.useCookies)</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            addCookies((baseUri ?: request.uri()), request.cookies)</span>

<span class="fc" id="L159">        val bodyBytes = bodyToBytes(request.body)</span>
<span class="fc" id="L160">        val queryParameters = request.queryParameters</span>
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">        val base = (baseUri?.toString() ?: &quot;&quot;) + request.path</span>
<span class="fc" id="L162">        val uri =</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (queryParameters.isEmpty()) base</span>
<span class="fc" id="L164">            else base + '?' + formatQueryString(queryParameters)</span>

<span class="fc" id="L166">        val javaRequest = JavaHttpRequest</span>
<span class="fc" id="L167">            .newBuilder(URI(uri))</span>
<span class="fc" id="L168">            .method(request.method.toString(), BodyPublishers.ofByteArray(bodyBytes))</span>

<span class="fc" id="L170">        request.headers.all.forEach { (name, values) -&gt;</span>
            // TODO Maybe accept-encoding interferes with H2C
<span class="pc bpc" id="L172" title="2 of 6 branches missed.">            if (name != &quot;accept-encoding&quot; &amp;&amp; values.isNotEmpty()) {</span>
<span class="fc" id="L173">                val kvs = values.flatMap { v -&gt; listOf(name, v.text) }.toTypedArray()</span>
<span class="fc" id="L174">                javaRequest.headers(*kvs)</span>
            }
<span class="fc" id="L176">        }</span>

        // TODO Remove these fields and handle them as headers
<span class="fc bfc" id="L179" title="All 2 branches covered.">        request.contentType?.let { javaRequest.setHeader(&quot;content-type&quot;, it.text) }</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        request.authorization?.let { javaRequest.setHeader(&quot;authorization&quot;, it.text) }</span>
<span class="pc" id="L181">        request.accept.forEach { javaRequest.setHeader(&quot;accept&quot;, it.text) }</span>

<span class="fc" id="L183">        return javaRequest.build()</span>
    }

    private fun addCookies(uri: URI, cookies: List&lt;Cookie&gt;) {
<span class="fc" id="L187">        cookies.forEach {</span>
<span class="fc" id="L188">            val httpCookie = HttpCookie(it.name, it.value)</span>
<span class="fc" id="L189">            httpCookie.secure = it.secure</span>
<span class="fc" id="L190">            httpCookie.maxAge = it.maxAge</span>
<span class="fc" id="L191">            httpCookie.path = it.path</span>
<span class="fc" id="L192">            httpCookie.isHttpOnly = it.httpOnly</span>
<span class="fc" id="L193">            httpCookie.path = it.path</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">            it.domain?.let(httpCookie::setDomain)</span>

<span class="fc" id="L196">            cookieManager.cookieStore.add(uri, httpCookie)</span>
<span class="fc" id="L197">        }</span>
<span class="fc" id="L198">    }</span>

    private fun convertResponse(response: JavaHttpResponse&lt;ByteArray&gt;): HttpResponse {

<span class="fc" id="L202">        val bodyString = String(response.body())</span>
<span class="fc" id="L203">        val headers = response.headers()</span>
<span class="fc" id="L204">        val cookies =</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (httpSettings.useCookies)</span>
<span class="fc" id="L206">                cookieManager.cookieStore.cookies.map {</span>
<span class="fc" id="L207">                    Cookie(</span>
<span class="fc" id="L208">                        it.name,</span>
<span class="fc" id="L209">                        it.value,</span>
<span class="fc" id="L210">                        it.maxAge,</span>
<span class="fc" id="L211">                        it.secure,</span>
<span class="fc" id="L212">                        it.path,</span>
<span class="fc" id="L213">                        it.isHttpOnly,</span>
<span class="fc" id="L214">                        it.domain,</span>
<span class="fc" id="L215">                    )</span>
                }
            else
<span class="fc" id="L218">                emptyList()</span>

<span class="fc" id="L220">        httpClient.cookies = cookies</span>

<span class="fc" id="L222">        val contentType = headers.firstValue(&quot;content-type&quot;).orElse(null)</span>
<span class="fc" id="L223">        return HttpResponse(</span>
<span class="fc" id="L224">            body = bodyString,</span>
<span class="fc" id="L225">            headers = convertHeaders(headers),</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            contentType = contentType?.let { parseContentType(it) },</span>
<span class="fc" id="L227">            cookies = cookies,</span>
<span class="fc" id="L228">            status = response.statusCode(),</span>
<span class="fc" id="L229">            contentLength = bodyString.length.toLong(),</span>
        )
    }

    private fun convertHeaders(headers: HttpHeaders): Headers =
<span class="fc" id="L234">        Headers(headers.map().flatMap { (k, v) -&gt; v.map { Header(k, it) } })</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>