<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Command.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagontk.args</a> &gt; <span class="el_source">Command.kt</span></div><h1>Command.kt</h1><pre class="source lang-java linenums">package com.hexagontk.args

import com.hexagontk.helpers.requireNotBlank

/**
 * A program can have multiple commands with their own set of options and positional parameters.
 *
 * TODO Support aliases
 */
<span class="fc" id="L10">data class Command(</span>
<span class="fc" id="L11">    val name: String,</span>
<span class="fc" id="L12">    val title: String? = null,</span>
<span class="fc" id="L13">    val description: String? = null,</span>
<span class="fc" id="L14">    val properties: Set&lt;Property&lt;*&gt;&gt; = emptySet(),</span>
<span class="fc" id="L15">    val subcommands: Set&lt;Command&gt; = emptySet(),</span>
<span class="fc" id="L16">) {</span>
<span class="fc" id="L17">    val flags: Set&lt;Flag&gt; =</span>
<span class="fc" id="L18">        properties.filterIsInstance&lt;Flag&gt;().toSet()</span>

<span class="fc" id="L20">    val options: Set&lt;Option&lt;*&gt;&gt; =</span>
<span class="fc" id="L21">        properties.filterIsInstance&lt;Option&lt;*&gt;&gt;().toSet()</span>

<span class="fc" id="L23">    val parameters: Set&lt;Parameter&lt;*&gt;&gt; =</span>
<span class="fc" id="L24">        properties.filterIsInstance&lt;Parameter&lt;*&gt;&gt;().toSet()</span>

<span class="fc" id="L26">    val propertiesMap: Map&lt;String, Property&lt;*&gt;&gt; =</span>
<span class="fc" id="L27">        properties</span>
<span class="fc" id="L28">            .flatMap { p -&gt; p.names.map { it to p } }</span>
<span class="fc" id="L29">            .toMap()</span>

<span class="fc" id="L31">    val optionsMap: Map&lt;String, Option&lt;*&gt;&gt; =</span>
<span class="fc" id="L32">        propertiesMap</span>
<span class="fc" id="L33">            .filterValues { it is Option&lt;*&gt; }</span>
<span class="fc" id="L34">            .mapValues { it.value as Option&lt;*&gt; }</span>

<span class="fc" id="L36">    val parametersMap: Map&lt;String, Parameter&lt;*&gt;&gt; =</span>
<span class="fc" id="L37">        propertiesMap</span>
<span class="fc" id="L38">            .filterValues { it is Parameter&lt;*&gt; }</span>
<span class="fc" id="L39">            .mapValues { it.value as Parameter&lt;*&gt; }</span>

<span class="fc" id="L41">    val subcommandsMap: Map&lt;String, Command&gt; =</span>
<span class="fc" id="L42">        nestedSubcommands().associateBy { it.name }</span>

    private val emptyPropertiesMap: Map&lt;String, Property&lt;*&gt;&gt; =
<span class="fc" id="L45">        propertiesMap.mapValues { (_, v) -&gt;</span>
<span class="fc" id="L46">            when (v) {</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">                is Option&lt;*&gt; -&gt; v.copy(values = emptyList())</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">                is Parameter&lt;*&gt; -&gt; v.copy(values = emptyList())</span>
<span class="fc" id="L49">                is Flag -&gt; v.copy(values = emptyList())</span>
<span class="fc" id="L50">            }</span>
        }

<span class="fc" id="L53">    private val emptyParametersList: List&lt;Parameter&lt;*&gt;&gt; by lazy {</span>
<span class="fc" id="L54">        parameters.map { it.copy(values = emptyList()) }</span>
    }

<span class="fc" id="L57">    init {</span>
<span class="fc" id="L58">        requireNotBlank(Command::name)</span>
<span class="fc" id="L59">        requireNotBlank(Command::title)</span>
<span class="fc" id="L60">        requireNotBlank(Command::description)</span>

<span class="fc bfc" id="L62" title="All 4 branches covered.">        if (parametersMap.isNotEmpty()) {</span>
<span class="fc" id="L63">            val parameters = parametersMap.values.reversed().drop(1)</span>
<span class="fc bfc" id="L64" title="All 4 branches covered.">            require(parameters.all { !it.multiple }) {</span>
<span class="fc" id="L65">                &quot;Only the last positional parameter can be multiple&quot;</span>
            }
        }
<span class="fc" id="L68">    }</span>

    fun findCommand(args: Iterable&lt;String&gt;): Command {
<span class="fc" id="L71">        val line = args.joinToString(&quot; &quot;)</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        return subcommandsMap</span>
<span class="fc" id="L73">            .mapKeys { it.key.removePrefix(&quot;$name &quot;) }</span>
<span class="fc" id="L74">            .entries</span>
<span class="fc" id="L75">            .sortedByDescending { it.key.count { c -&gt; c == ' ' } }</span>
<span class="fc bfc" id="L76" title="All 4 branches covered.">            .find { line.contains(it.key) }</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            ?.let { (k, v) -&gt; v.copy(name = k) }</span>
<span class="fc" id="L78">            ?: this</span>
    }

    fun parse(args: List&lt;String&gt;): Command {
<span class="fc" id="L82">        val argsIterator = args.iterator()</span>
<span class="fc" id="L83">        var parsedProperties = emptyList&lt;Property&lt;*&gt;&gt;()</span>
<span class="fc" id="L84">        var parsedParameter = 0</span>

<span class="fc" id="L86">        argsIterator.forEach { value -&gt;</span>
<span class="fc" id="L87">            parsedProperties = when {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">                value.startsWith(&quot;--&quot;) -&gt;</span>
<span class="fc" id="L89">                    parsedProperties + parseOption(value.removePrefix(&quot;--&quot;), argsIterator)</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">                value.startsWith('-') -&gt;</span>
<span class="fc" id="L92">                    parsedProperties + parseOptions(value.removePrefix(&quot;-&quot;), argsIterator)</span>

                else -&gt;
<span class="fc" id="L95">                    parsedProperties + parseParameter(value, ++parsedParameter)</span>
            }
<span class="fc" id="L97">        }</span>

<span class="fc" id="L99">        val groupedProperties = addDefaultProperties(parsedProperties.groupValues())</span>
<span class="fc" id="L100">        checkMandatoryProperties(groupedProperties)</span>
<span class="fc" id="L101">        return copy(properties = groupedProperties.toSet())</span>
    }

    private fun addDefaultProperties(groupedProperties: List&lt;Property&lt;*&gt;&gt;): List&lt;Property&lt;*&gt;&gt; =
<span class="fc" id="L105">        groupedProperties + properties</span>
<span class="fc bfc" id="L106" title="All 6 branches covered.">            .filter { it.optional &amp;&amp; it.values.isNotEmpty() }</span>
<span class="fc" id="L107">            .filterNot { it.names.any { n -&gt; n in groupedProperties.flatMap { gp -&gt; gp.names } } }</span>

    @Suppress(&quot;UNCHECKED_CAST&quot;) // Types checked at runtime
    fun &lt;T : Any&gt; propertyValues(name: String): List&lt;T&gt; =
<span class="pc bpc" id="L111" title="2 of 6 branches missed.">        propertiesMap[name]?.values?.mapNotNull { it as? T } ?: emptyList()</span>

    fun &lt;T : Any&gt; propertyValueOrNull(name: String): T? =
<span class="fc" id="L114">        propertyValues&lt;T&gt;(name).firstOrNull()</span>

    fun &lt;T : Any&gt; propertyValue(name: String): T {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        return propertyValueOrNull(name) ?: error(&quot;Property '$name' does not have a value&quot;)</span>
    }

    private fun checkMandatoryProperties(parsedProperties: List&lt;Property&lt;*&gt;&gt;) {
<span class="fc" id="L121">        val mandatoryProperties = properties.filterNot { it.optional }</span>
<span class="fc" id="L122">        val names = parsedProperties.flatMap { it.names }</span>
<span class="fc" id="L123">        val missingProperties = mandatoryProperties.filterNot { it.names.any { n -&gt; n in names } }</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        check(missingProperties.isEmpty()) {</span>
<span class="fc" id="L125">            val missingNames = missingProperties.joinToString(&quot;, &quot;) { &quot;'${it.names.first()}'&quot; }</span>
<span class="fc" id="L126">            &quot;Missing properties: $missingNames&quot;</span>
        }
<span class="fc" id="L128">    }</span>

    private fun List&lt;Property&lt;*&gt;&gt;.groupValues(): List&lt;Property&lt;*&gt;&gt; =
<span class="fc" id="L131">        groupBy { it.names }</span>
<span class="fc" id="L132">            .map { (_, v) -&gt;</span>
<span class="fc" id="L133">                v.reduceIndexed { i, a, b -&gt;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                    if (a.multiple) a.addValues(b)</span>
<span class="fc" id="L135">                    else error(&quot;Unknown argument at position ${i + 1}: ${b.values.first()}&quot;)</span>
<span class="fc" id="L136">                }</span>
<span class="fc" id="L137">            }</span>

    private fun parseParameter(value: String, parsedParameter: Int): Property&lt;*&gt; =
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        (emptyParametersList.getOrNull(parsedParameter) ?: emptyParametersList.lastOrNull())</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            ?.addValue(value)</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            ?: error(&quot;No parameters&quot;)</span>

    private fun parseOptions(
        names: String, argsIterator: Iterator&lt;String&gt;
    ): Collection&lt;Property&lt;*&gt;&gt; {
<span class="fc" id="L147">        val namesIterator = names.iterator()</span>
<span class="fc" id="L148">        var result = emptyList&lt;Property&lt;*&gt;&gt;()</span>

<span class="fc" id="L150">        namesIterator.forEach {</span>
<span class="fc" id="L151">            val name = it.toString()</span>
<span class="fc" id="L152">            val isOption = optionsMap.contains(name)</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">            val option = if (isOption &amp;&amp; namesIterator.hasNext()) {</span>
<span class="fc" id="L154">                val firstValueChar = namesIterator.next()</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                val valueStart = if (firstValueChar != '=') &quot;=$firstValueChar&quot; else firstValueChar</span>
<span class="fc" id="L156">                val buffer = StringBuffer(name + valueStart)</span>

<span class="fc" id="L158">                namesIterator.forEachRemaining(buffer::append)</span>
<span class="fc" id="L159">                buffer.toString()</span>
            }
<span class="fc" id="L161">            else name</span>

<span class="fc" id="L163">            result = result + parseOption(option, argsIterator)</span>
<span class="fc" id="L164">        }</span>

<span class="fc" id="L166">        return result</span>
    }

    private fun parseOption(option: String, propertiesIterator: Iterator&lt;String&gt;): Property&lt;*&gt; {
<span class="fc" id="L170">        val nameValue = option.split('=', limit = 2)</span>
<span class="fc" id="L171">        val name = nameValue.first()</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        val property = emptyPropertiesMap[name] ?: error(&quot;Option '$name' not found&quot;)</span>
<span class="fc" id="L173">        val value =</span>
<span class="fc bfc" id="L174" title="All 4 branches covered.">            if (property is Option&lt;*&gt;) nameValue.getOrNull(1) ?: propertiesIterator.next()</span>
<span class="fc" id="L175">            else &quot;true&quot;</span>

<span class="fc" id="L177">        return property.addValue(value)</span>
    }

    private fun nestedSubcommands(): Set&lt;Command&gt; =
<span class="fc" id="L181">        subcommands</span>
<span class="fc" id="L182">            .map { it.copy(name = name + &quot; &quot; + it.name) }</span>
<span class="fc" id="L183">            .let { c -&gt; c + c.flatMap { it.nestedSubcommands() } }</span>
<span class="fc" id="L184">            .toSet()</span>

    fun contains(flag: Flag, args: Iterable&lt;String&gt;): Boolean =
<span class="fc" id="L187">        flags</span>
<span class="fc" id="L188">            .flatMap { it.names }</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            .any { it in flag.names }</span>
<span class="fc" id="L190">            &amp;&amp; args</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                .map { it.dropWhile { c -&gt; c == '-' } }</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                .any { it in flag.names }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>