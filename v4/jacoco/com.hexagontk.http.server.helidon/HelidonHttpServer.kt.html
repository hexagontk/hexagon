<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelidonHttpServer.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagontk.http.server.helidon</a> &gt; <span class="el_source">HelidonHttpServer.kt</span></div><h1>HelidonHttpServer.kt</h1><pre class="source lang-java linenums">package com.hexagontk.http.server.helidon

import com.hexagontk.core.fieldsMapOf
import com.hexagontk.core.media.TEXT_PLAIN
import com.hexagontk.core.security.createKeyManagerFactory
import com.hexagontk.core.security.createTrustManagerFactory
import com.hexagontk.core.toText
import com.hexagontk.http.SslSettings
import com.hexagontk.http.handlers.bodyToBytes
import com.hexagontk.http.handlers.HttpHandler
import com.hexagontk.http.model.HttpProtocol
import com.hexagontk.http.model.HttpProtocol.*
import com.hexagontk.http.model.HttpResponse
import com.hexagontk.http.model.HttpResponsePort
import com.hexagontk.http.server.HttpServer
import com.hexagontk.http.HttpFeature
import com.hexagontk.http.HttpFeature.*
import com.hexagontk.http.server.HttpServerPort
import io.helidon.common.socket.SocketOptions
import io.helidon.http.Method
import io.helidon.http.Status
import io.helidon.http.HeaderNames
import io.helidon.http.HeaderNames.CONTENT_TYPE
import io.helidon.http.HttpMediaType
import io.helidon.http.SetCookie
import io.helidon.webserver.WebServer
import io.helidon.webserver.http.ServerResponse
import io.helidon.webserver.http1.Http1Config
import io.helidon.webserver.http2.Http2Config
import java.security.SecureRandom
import java.time.Duration
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLParameters
import javax.net.ssl.TrustManagerFactory

/**
 * Implements [HttpServerPort] using Helidon.
 *
 * TODO Add settings for HTTP2 and separate them on constructor parameters
 */
<span class="pc" id="L42">class HelidonHttpServer(</span>
<span class="pc" id="L43">    private val backlog: Int = 1_024,</span>
<span class="pc" id="L44">    private val writeQueueLength: Int = 0,</span>
<span class="pc" id="L45">    private val readTimeout: Duration = Duration.ofSeconds(30),</span>
<span class="pc" id="L46">    private val connectTimeout: Duration = Duration.ofSeconds(10),</span>
<span class="pc" id="L47">    private val tcpNoDelay: Boolean = false,</span>
<span class="pc" id="L48">    private val receiveLog: Boolean = true,</span>
<span class="pc" id="L49">    private val sendLog: Boolean = true,</span>
<span class="pc" id="L50">    private val validatePath: Boolean = true,</span>
<span class="pc" id="L51">    private val validateRequestHeaders: Boolean = true,</span>
<span class="pc" id="L52">    private val validateResponseHeaders: Boolean = false,</span>
<span class="pc" id="L53">    private val smartAsyncWrites: Boolean = false,</span>
<span class="nc" id="L54">) : HttpServerPort {</span>

    private companion object {
        const val START_ERROR_MESSAGE = &quot;Helidon server not started correctly&quot;
    }

    private var helidonServer: WebServer? = null

<span class="fc" id="L62">    constructor() : this(</span>
<span class="fc" id="L63">        backlog = 1_024,</span>
<span class="fc" id="L64">        writeQueueLength = 0,</span>
<span class="fc" id="L65">        readTimeout = Duration.ofSeconds(30),</span>
<span class="fc" id="L66">        connectTimeout = Duration.ofSeconds(10),</span>
<span class="fc" id="L67">        tcpNoDelay = false,</span>
<span class="fc" id="L68">        receiveLog = true,</span>
<span class="fc" id="L69">        sendLog = true,</span>
<span class="fc" id="L70">        validatePath = true,</span>
<span class="fc" id="L71">        validateRequestHeaders = true,</span>
<span class="fc" id="L72">        validateResponseHeaders = false,</span>
<span class="fc" id="L73">        smartAsyncWrites = false,</span>
<span class="fc" id="L74">    )</span>

    override fun runtimePort(): Int {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        return helidonServer?.port() ?: error(START_ERROR_MESSAGE)</span>
    }

    override fun started() =
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        helidonServer?.isRunning ?: false</span>

    override fun startUp(server: HttpServer) {
<span class="fc" id="L84">        val settings = server.settings</span>
<span class="fc" id="L85">        val sslSettings = settings.sslSettings</span>

<span class="fc" id="L87">        val handlers: Map&lt;Method, HttpHandler&gt; =</span>
<span class="fc" id="L88">            server.handler</span>
<span class="fc" id="L89">                .byMethod()</span>
<span class="fc" id="L90">                .mapKeys { Method.create(it.key.toString()) }</span>

        // TODO features(): [Config, Encoding, Media, WebServer] Maybe Multipart can be added there
<span class="fc" id="L93">        val serverBuilder = WebServer</span>
<span class="fc" id="L94">            .builder()</span>
<span class="fc" id="L95">            .host(settings.bindAddress.hostName)</span>
<span class="fc" id="L96">            .port(settings.bindPort)</span>
<span class="fc" id="L97">            .routing {</span>
<span class="fc" id="L98">                it.any({ helidonRequest, helidonResponse -&gt;</span>
<span class="fc" id="L99">                    val method = helidonRequest.prologue().method()</span>
<span class="fc" id="L100">                    val request = HelidonRequestAdapter(method, helidonRequest)</span>
<span class="pc bpc" id="L101" title="3 of 6 branches missed.">                    val response = handlers[method]?.process(request)?.response ?: HttpResponse()</span>
<span class="fc" id="L102">                    setResponse(request.protocol.secure, response, helidonResponse)</span>
<span class="fc" id="L103">                })</span>
<span class="fc" id="L104">            }</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (sslSettings != null)</span>
<span class="fc" id="L107">            serverBuilder.tls {</span>
<span class="fc" id="L108">                val sslClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L109">                it</span>
<span class="fc" id="L110">                    .sslParameters(SSLParameters().apply { needClientAuth = sslClientAuth })</span>
<span class="fc" id="L111">                    .sslContext(sslContext(sslSettings))</span>
<span class="fc" id="L112">            }</span>

<span class="fc" id="L114">        val protocolConfig =</span>
<span class="fc bfc" id="L115" title="All 4 branches covered.">            if (settings.protocol == HTTP || settings.protocol == HTTPS)</span>
                Http1Config
<span class="fc" id="L117">                    .builder()</span>
<span class="fc" id="L118">                    .receiveLog(receiveLog)</span>
<span class="fc" id="L119">                    .sendLog(sendLog)</span>
<span class="fc" id="L120">                    .validatePath(validatePath)</span>
<span class="fc" id="L121">                    .validateRequestHeaders(validateRequestHeaders)</span>
<span class="fc" id="L122">                    .validateResponseHeaders(validateResponseHeaders)</span>
<span class="fc" id="L123">                    .build()</span>
            else
                Http2Config
<span class="fc" id="L126">                    .builder()</span>
<span class="fc" id="L127">                    .validatePath(validatePath)</span>
<span class="fc" id="L128">                    .build()</span>

<span class="fc" id="L130">        helidonServer = serverBuilder</span>
<span class="fc" id="L131">            .backlog(backlog)</span>
<span class="fc" id="L132">            .writeQueueLength(writeQueueLength)</span>
<span class="fc" id="L133">            .smartAsyncWrites(smartAsyncWrites)</span>
<span class="fc" id="L134">            .connectionOptions(SocketOptions</span>
<span class="fc" id="L135">                .builder()</span>
<span class="fc" id="L136">                .readTimeout(readTimeout)</span>
<span class="fc" id="L137">                .connectTimeout(connectTimeout)</span>
<span class="fc" id="L138">                .tcpNoDelay(tcpNoDelay)</span>
<span class="fc" id="L139">                .build()</span>
            )
<span class="fc" id="L141">            .protocols(listOf(protocolConfig))</span>
<span class="fc" id="L142">            .build()</span>

<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        helidonServer?.start() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L145">    }</span>

    override fun shutDown() {
<span class="pc bpc" id="L148" title="2 of 4 branches missed.">        helidonServer?.stop() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L149">    }</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="fc" id="L152">        setOf(HTTP, HTTPS, HTTP2)</span>

    override fun supportedFeatures(): Set&lt;HttpFeature&gt; =
<span class="fc" id="L155">        setOf(ZIP, COOKIES, MULTIPART)</span>

    override fun options(): Map&lt;String, *&gt; =
<span class="fc" id="L158">        fieldsMapOf(</span>
<span class="fc" id="L159">            HelidonHttpServer::backlog to backlog,</span>
<span class="fc" id="L160">            HelidonHttpServer::writeQueueLength to writeQueueLength,</span>
<span class="fc" id="L161">            HelidonHttpServer::readTimeout to readTimeout,</span>
<span class="fc" id="L162">            HelidonHttpServer::connectTimeout to connectTimeout,</span>
<span class="fc" id="L163">            HelidonHttpServer::tcpNoDelay to tcpNoDelay,</span>
<span class="fc" id="L164">            HelidonHttpServer::receiveLog to receiveLog,</span>
<span class="fc" id="L165">            HelidonHttpServer::sendLog to sendLog,</span>
<span class="fc" id="L166">            HelidonHttpServer::validatePath to validatePath,</span>
<span class="fc" id="L167">            HelidonHttpServer::validateRequestHeaders to validateRequestHeaders,</span>
<span class="fc" id="L168">            HelidonHttpServer::validateResponseHeaders to validateResponseHeaders,</span>
<span class="fc" id="L169">            HelidonHttpServer::smartAsyncWrites to smartAsyncWrites,</span>
<span class="fc" id="L170">        )</span>

    private fun setResponse(
        secureRequest: Boolean,
        response: HttpResponsePort,
        helidonResponse: ServerResponse
    ) {
<span class="fc" id="L177">        try {</span>
<span class="fc" id="L178">            helidonResponse.status(Status.create(response.status))</span>

<span class="fc" id="L180">            response.headers.all.forEach { (k, v) -&gt;</span>
<span class="fc" id="L181">                helidonResponse.header(HeaderNames.create(k), *v.map { it.text }.toTypedArray())</span>
<span class="fc" id="L182">            }</span>

<span class="fc" id="L184">            val headers = helidonResponse.headers()</span>
<span class="fc" id="L185">            response.cookies</span>
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">                .filter { if (secureRequest) true else !it.secure }</span>
<span class="fc" id="L187">                .forEach {</span>
<span class="fc" id="L188">                    val cookie = SetCookie</span>
<span class="fc" id="L189">                        .builder(it.name, it.value)</span>
<span class="fc" id="L190">                        .maxAge(Duration.ofSeconds(it.maxAge))</span>
<span class="fc" id="L191">                        .path(it.path)</span>
<span class="fc" id="L192">                        .httpOnly(it.httpOnly)</span>
<span class="fc" id="L193">                        .secure(it.secure)</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">                    if (it.expires != null)</span>
<span class="nc" id="L196">                        cookie.expires(it.expires)</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">                    if (it.deleted)</span>
<span class="fc" id="L199">                        headers.clearCookie(it.name)</span>
                    else
<span class="fc" id="L201">                        headers.addCookie(cookie.build())</span>
<span class="fc" id="L202">                }</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">            response.contentType?.let { ct -&gt; headers.contentType(HttpMediaType.create(ct.text)) }</span>

<span class="fc" id="L206">            helidonResponse.send(bodyToBytes(response.body))</span>
        }
<span class="fc" id="L208">        catch (e: Exception) {</span>
<span class="fc" id="L209">            helidonResponse.status(Status.INTERNAL_SERVER_ERROR_500)</span>
<span class="fc" id="L210">            helidonResponse.header(CONTENT_TYPE, TEXT_PLAIN.fullType)</span>
<span class="fc" id="L211">            helidonResponse.send(bodyToBytes(e.toText()))</span>
        }
<span class="fc" id="L213">    }</span>

    private fun sslContext(sslSettings: SslSettings): SSLContext {
<span class="fc" id="L216">        val keyManager = keyManagerFactory(sslSettings)</span>
<span class="fc" id="L217">        val trustManager = trustManagerFactory(sslSettings)</span>

<span class="fc" id="L219">        val eng = SSLContext.getDefault().createSSLEngine()</span>
<span class="fc" id="L220">        eng.needClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L221">        val context = SSLContext.getInstance(&quot;TLSv1.3&quot;)</span>
<span class="fc" id="L222">        context.init(</span>
<span class="fc" id="L223">            keyManager.keyManagers,</span>
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">            trustManager?.trustManagers ?: emptyArray(),</span>
<span class="fc" id="L225">            SecureRandom.getInstanceStrong()</span>
        )
<span class="fc" id="L227">        return context</span>
    }

    private fun trustManagerFactory(sslSettings: SslSettings): TrustManagerFactory? {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        val trustStoreUrl = sslSettings.trustStore ?: return null</span>
<span class="fc" id="L232">        val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L233">        return createTrustManagerFactory(trustStoreUrl, trustStorePassword)</span>
    }

    private fun keyManagerFactory(sslSettings: SslSettings): KeyManagerFactory {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        val keyStoreUrl = sslSettings.keyStore ?: error(&quot;&quot;)</span>
<span class="fc" id="L238">        val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L239">        return createKeyManagerFactory(keyStoreUrl, keyStorePassword)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>