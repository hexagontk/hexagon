<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelidonHttpServer.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">site</a> &gt; <a href="index.source.html" class="el_package">com.hexagontk.http.server.helidon</a> &gt; <span class="el_source">HelidonHttpServer.kt</span></div><h1>HelidonHttpServer.kt</h1><pre class="source lang-java linenums">package com.hexagontk.http.server.helidon

import com.hexagontk.core.fieldsMapOf
import com.hexagontk.core.security.createKeyManagerFactory
import com.hexagontk.core.security.createTrustManagerFactory
import com.hexagontk.core.toText
import com.hexagontk.http.SslSettings
import com.hexagontk.http.handlers.bodyToBytes
import com.hexagontk.http.handlers.HttpHandler
import com.hexagontk.http.model.HttpProtocol
import com.hexagontk.http.model.HttpProtocol.*
import com.hexagontk.http.model.HttpResponse
import com.hexagontk.http.model.HttpResponsePort
import com.hexagontk.http.server.HttpServer
import com.hexagontk.http.HttpFeature
import com.hexagontk.http.HttpFeature.*
import com.hexagontk.http.server.HttpServerPort
import io.helidon.common.socket.SocketOptions
import io.helidon.http.Method
import io.helidon.http.Status
import io.helidon.http.HeaderNames
import io.helidon.http.HttpMediaType
import io.helidon.http.SetCookie
import io.helidon.webserver.WebServer
import io.helidon.webserver.http.ServerResponse
import io.helidon.webserver.http1.Http1Config
import io.helidon.webserver.http2.Http2Config
import java.security.SecureRandom
import java.time.Duration
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLParameters
import javax.net.ssl.TrustManagerFactory

/**
 * Implements [HttpServerPort] using Helidon.
 *
 * TODO Add settings for HTTP2 and separate them on constructor parameters
 */
<span class="fc" id="L40">class HelidonHttpServer(</span>
<span class="fc" id="L41">    private val backlog: Int = 1_024,</span>
<span class="fc" id="L42">    private val writeQueueLength: Int = 0,</span>
<span class="fc" id="L43">    private val readTimeout: Duration = Duration.ofSeconds(30),</span>
<span class="fc" id="L44">    private val connectTimeout: Duration = Duration.ofSeconds(10),</span>
<span class="fc" id="L45">    private val tcpNoDelay: Boolean = false,</span>
<span class="fc" id="L46">    private val receiveLog: Boolean = true,</span>
<span class="fc" id="L47">    private val sendLog: Boolean = true,</span>
<span class="fc" id="L48">    private val validatePath: Boolean = true,</span>
<span class="fc" id="L49">    private val validateRequestHeaders: Boolean = true,</span>
<span class="fc" id="L50">    private val validateResponseHeaders: Boolean = false,</span>
<span class="fc" id="L51">) : HttpServerPort {</span>

    private companion object {
        const val START_ERROR_MESSAGE = &quot;Helidon server not started correctly&quot;
    }

    private var helidonServer: WebServer? = null

    override fun runtimePort(): Int {
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        return helidonServer?.port() ?: error(START_ERROR_MESSAGE)</span>
    }

    override fun started() =
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        helidonServer?.isRunning ?: false</span>

    override fun startUp(server: HttpServer) {
<span class="fc" id="L67">        val settings = server.settings</span>
<span class="fc" id="L68">        val sslSettings = settings.sslSettings</span>

<span class="fc" id="L70">        val handlers: Map&lt;Method, HttpHandler&gt; =</span>
<span class="fc" id="L71">            server.handler.addPrefix(settings.contextPath)</span>
<span class="fc" id="L72">                .byMethod()</span>
<span class="fc" id="L73">                .mapKeys { Method.create(it.key.toString()) }</span>

        // TODO features(): [Config, Encoding, Media, WebServer] Maybe Multipart can be added there
<span class="fc" id="L76">        val serverBuilder = WebServer</span>
<span class="fc" id="L77">            .builder()</span>
<span class="fc" id="L78">            .host(settings.bindAddress.hostName)</span>
<span class="fc" id="L79">            .port(settings.bindPort)</span>
<span class="fc" id="L80">            .routing {</span>
<span class="fc" id="L81">                it.any({ helidonRequest, helidonResponse -&gt;</span>
<span class="fc" id="L82">                    val method = helidonRequest.prologue().method()</span>
<span class="fc" id="L83">                    val request = HelidonRequestAdapter(method, helidonRequest)</span>
<span class="pc bpc" id="L84" title="3 of 6 branches missed.">                    val response = handlers[method]?.process(request)?.response ?: HttpResponse()</span>
<span class="fc" id="L85">                    setResponse(request.protocol.secure, response, helidonResponse)</span>
<span class="fc" id="L86">                })</span>
<span class="fc" id="L87">            }</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (sslSettings != null)</span>
<span class="fc" id="L90">            serverBuilder.tls {</span>
<span class="fc" id="L91">                val sslClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L92">                it</span>
<span class="fc" id="L93">                    .sslParameters(SSLParameters().apply { needClientAuth = sslClientAuth })</span>
<span class="fc" id="L94">                    .sslContext(sslContext(sslSettings))</span>
<span class="fc" id="L95">            }</span>

<span class="fc" id="L97">        val protocolConfig =</span>
<span class="fc bfc" id="L98" title="All 4 branches covered.">            if (settings.protocol == HTTP || settings.protocol == HTTPS)</span>
                Http1Config
<span class="fc" id="L100">                    .builder()</span>
<span class="fc" id="L101">                    .receiveLog(receiveLog)</span>
<span class="fc" id="L102">                    .sendLog(sendLog)</span>
<span class="fc" id="L103">                    .validatePath(validatePath)</span>
<span class="fc" id="L104">                    .validateRequestHeaders(validateRequestHeaders)</span>
<span class="fc" id="L105">                    .validateResponseHeaders(validateResponseHeaders)</span>
<span class="fc" id="L106">                    .build()</span>
            else
                Http2Config
<span class="fc" id="L109">                    .builder()</span>
<span class="fc" id="L110">                    .validatePath(validatePath)</span>
<span class="fc" id="L111">                    .build()</span>

<span class="fc" id="L113">        helidonServer = serverBuilder</span>
<span class="fc" id="L114">            .backlog(backlog)</span>
<span class="fc" id="L115">            .writeQueueLength(writeQueueLength)</span>
<span class="fc" id="L116">            .connectionOptions(SocketOptions</span>
<span class="fc" id="L117">                .builder()</span>
<span class="fc" id="L118">                .readTimeout(readTimeout)</span>
<span class="fc" id="L119">                .connectTimeout(connectTimeout)</span>
<span class="fc" id="L120">                .tcpNoDelay(tcpNoDelay)</span>
<span class="fc" id="L121">                .build()</span>
            )
<span class="fc" id="L123">            .protocols(listOf(protocolConfig))</span>
<span class="fc" id="L124">            .build()</span>

<span class="pc bpc" id="L126" title="2 of 4 branches missed.">        helidonServer?.start() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L127">    }</span>

    override fun shutDown() {
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">        helidonServer?.stop() ?: error(START_ERROR_MESSAGE)</span>
<span class="fc" id="L131">    }</span>

    override fun supportedProtocols(): Set&lt;HttpProtocol&gt; =
<span class="fc" id="L134">        setOf(HTTP, HTTPS, HTTP2)</span>

    override fun supportedFeatures(): Set&lt;HttpFeature&gt; =
<span class="fc" id="L137">        setOf(ZIP, COOKIES)</span>

    override fun options(): Map&lt;String, *&gt; =
<span class="fc" id="L140">        fieldsMapOf(</span>
<span class="fc" id="L141">            HelidonHttpServer::backlog to backlog,</span>
<span class="fc" id="L142">            HelidonHttpServer::writeQueueLength to writeQueueLength,</span>
<span class="fc" id="L143">            HelidonHttpServer::readTimeout to readTimeout,</span>
<span class="fc" id="L144">            HelidonHttpServer::connectTimeout to connectTimeout,</span>
<span class="fc" id="L145">            HelidonHttpServer::tcpNoDelay to tcpNoDelay,</span>
<span class="fc" id="L146">            HelidonHttpServer::receiveLog to receiveLog,</span>
<span class="fc" id="L147">            HelidonHttpServer::sendLog to sendLog,</span>
<span class="fc" id="L148">            HelidonHttpServer::validatePath to validatePath,</span>
<span class="fc" id="L149">            HelidonHttpServer::validateRequestHeaders to validateRequestHeaders,</span>
<span class="fc" id="L150">            HelidonHttpServer::validateResponseHeaders to validateResponseHeaders,</span>
<span class="fc" id="L151">        )</span>

    private fun setResponse(
        secureRequest: Boolean,
        response: HttpResponsePort,
        helidonResponse: ServerResponse
    ) {
<span class="fc" id="L158">        try {</span>
<span class="fc" id="L159">            helidonResponse.status(Status.create(response.status))</span>

<span class="fc" id="L161">            response.headers.all.forEach { (k, v) -&gt;</span>
<span class="fc" id="L162">                helidonResponse.header(HeaderNames.create(k), *v.map { it.text }.toTypedArray())</span>
<span class="fc" id="L163">            }</span>

<span class="fc" id="L165">            val headers = helidonResponse.headers()</span>
<span class="fc" id="L166">            response.cookies</span>
<span class="pc bpc" id="L167" title="1 of 4 branches missed.">                .filter { if (secureRequest) true else !it.secure }</span>
<span class="fc" id="L168">                .forEach {</span>
<span class="fc" id="L169">                    val cookie = SetCookie</span>
<span class="fc" id="L170">                        .builder(it.name, it.value)</span>
<span class="fc" id="L171">                        .maxAge(Duration.ofSeconds(it.maxAge))</span>
<span class="fc" id="L172">                        .path(it.path)</span>
<span class="fc" id="L173">                        .httpOnly(it.httpOnly)</span>
<span class="fc" id="L174">                        .secure(it.secure)</span>

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                    if (it.expires != null)</span>
<span class="nc" id="L177">                        cookie.expires(it.expires)</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">                    if (it.deleted)</span>
<span class="fc" id="L180">                        headers.clearCookie(it.name)</span>
                    else
<span class="fc" id="L182">                        headers.addCookie(cookie.build())</span>
<span class="fc" id="L183">                }</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">            response.contentType?.let { ct -&gt; headers.contentType(HttpMediaType.create(ct.text)) }</span>

<span class="fc" id="L187">            helidonResponse.send(bodyToBytes(response.body))</span>
        }
<span class="fc" id="L189">        catch (e: Exception) {</span>
<span class="fc" id="L190">            helidonResponse.status(Status.INTERNAL_SERVER_ERROR_500)</span>
<span class="fc" id="L191">            helidonResponse.send(bodyToBytes(e.toText()))</span>
        }
<span class="fc" id="L193">    }</span>

    private fun sslContext(sslSettings: SslSettings): SSLContext {
<span class="fc" id="L196">        val keyManager = keyManagerFactory(sslSettings)</span>
<span class="fc" id="L197">        val trustManager = trustManagerFactory(sslSettings)</span>

<span class="fc" id="L199">        val eng = SSLContext.getDefault().createSSLEngine()</span>
<span class="fc" id="L200">        eng.needClientAuth = sslSettings.clientAuth</span>
<span class="fc" id="L201">        val context = SSLContext.getInstance(&quot;TLSv1.3&quot;)</span>
<span class="fc" id="L202">        context.init(</span>
<span class="fc" id="L203">            keyManager.keyManagers,</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">            trustManager?.trustManagers ?: emptyArray(),</span>
<span class="fc" id="L205">            SecureRandom.getInstanceStrong()</span>
        )
<span class="fc" id="L207">        return context</span>
    }

    private fun trustManagerFactory(sslSettings: SslSettings): TrustManagerFactory? {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        val trustStoreUrl = sslSettings.trustStore ?: return null</span>
<span class="fc" id="L212">        val trustStorePassword = sslSettings.trustStorePassword</span>
<span class="fc" id="L213">        return createTrustManagerFactory(trustStoreUrl, trustStorePassword)</span>
    }

    private fun keyManagerFactory(sslSettings: SslSettings): KeyManagerFactory {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        val keyStoreUrl = sslSettings.keyStore ?: error(&quot;&quot;)</span>
<span class="fc" id="L218">        val keyStorePassword = sslSettings.keyStorePassword</span>
<span class="fc" id="L219">        return createKeyManagerFactory(keyStoreUrl, keyStorePassword)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>