
final String sslCaFile = findProperty("sslCaFile") ?: "ca.p12"
final String sslCaAlias = findProperty("sslCaAlias") ?: "ca"
final String sslTrustFile = findProperty("sslTrustFile") ?: "trust.p12"

final String sslValidity = findProperty("sslValidity") ?: 365.toString()
final String sslCountry = findProperty("sslCountry") ?: System.getProperty("user.country")
final String sslOrganization = findProperty("sslOrganization")

task("createCa") {
    doLast {
        if (file(sslPath(sslCaFile)).exists())
            return

        // Create CA (root) key pair
        final String commonName = "$sslOrganization TEST Root CA"
        createKeyPair(sslCaFile, sslCaAlias, sslValidity, commonName, sslOrganization, sslCountry)

        // Create trust store with CA certificate (PEM)
        final String caPem = sslPath("ca.pem")
        keytool("-exportcert", sslCaFile, sslCaAlias, "-rfc", "-file", caPem)
        keytool("-importcert", sslTrustFile, sslCaAlias, "-file", caPem, "-noprompt")

        // Clean up
        delete(caPem)
    }
}

task("createIdentities") {
    doLast {
        final List<String> sslDomains = (("9".."1") + "")
            .reverse()
            .collect { findProperty("sslDomain$it")?.toString()?.trim() }
            .findAll { it != null }

        sslDomains.each { sslFullDomain ->
            final List<String> parts = sslFullDomain.trim().split("\\|").reverse()
            final String sslDomain = parts.head()
            final List<String> sslSubdomains = parts.tail()

            final int dotIndex = sslDomain.lastIndexOf('.')
            final String domain = sslDomain.substring(0, dotIndex)
            final String tld = sslDomain.substring(dotIndex + 1)
            final String storeFile = domain.replace(".", "_") + ".p12"

            if (file(sslPath(storeFile)).exists())
                return

            // Create key pairs
            createKeyPair(storeFile, domain, sslValidity, sslDomain, sslOrganization, sslCountry)

            // Export CA certificate
            final String caPem = sslPath("ca.pem")
            keytool("-exportcert", sslCaFile, sslCaAlias, "-rfc", "-file", caPem)

            // Generate chained server certificate (PEM)
            final String identityCsr = sslPath("identity.csr")
            final String identityPem = sslPath("identity.pem")
            final String identityChainPem = sslPath("identity_chain.pem")
            final String san = createSan(domain, tld, sslSubdomains)
            keytool("-certreq", storeFile, domain, "-ext", "san=${san}", "-file", identityCsr)
            keytool("-gencert", sslCaFile, sslCaAlias,
                "-validity", sslValidity,
                "-ext", "san=${san}",
                "-rfc",
                "-infile", identityCsr,
                "-outfile", identityPem
            )
            concatenate(identityChainPem, caPem, identityPem)

            // Replace server certificate with chained PEM
            keytool("-importcert", storeFile, domain, "-file", identityChainPem, "-noprompt")

            // Clean up
            delete(identityCsr, caPem, identityPem, identityChainPem)
        }
    }
}

private void createKeyPair(
    final String file,
    final String alias,
    final String validity,
    final String commonName,
    final String organization,
    final String country) {

    keytool("-genkeypair", file, alias,
        "-validity", validity,
        "-ext", "bc:ca:true",
        "-keyalg", "RSA",
        "-dname", "CN=$commonName,O=$organization,C=$country"
    )
}

private void concatenate(final String output, final String... files) {
    final File chain = project.file(output)
    logCommand([ "cat", files, ">>", output ].flatten())
    project.files(files).each { chain << it.text }
}

private String sslPath(final String fileName) {
    final String sslPath = findProperty("sslPath")

    final File sslPathFile = file(sslPath == null? project.buildDir.absolutePath : sslPath)
    if (!sslPathFile.exists())
        sslPathFile.mkdir()

    if (sslPath == null)
        return project.buildDir.absolutePath + "/" + fileName

    final List<String> pathSegments = [ projectDir.absolutePath, sslPath, fileName ]
    return pathSegments.findAll { !it.isBlank() }.join("/")
}

private void keytool(
    final String command,
    final String keystore,
    final String alias,
    final Object... others) {

    final String sslPassword = findProperty("sslPassword")
    final String storePassword = sslPassword ?: keystore.reverse()
    final String keystorePath = sslPath(keystore)

    final List<String> commandList = [
        "keytool", command,
        "-keystore", keystorePath,
        "-storetype", "pkcs12",
        "-storepass", storePassword,
        "-alias", alias
    ]

    final List<Object> fullCommand = commandList + others.toList()
    logCommand(fullCommand)
    project.exec { commandLine(fullCommand) }
}

private void logCommand(final List<Object> fullCommand) {
    final boolean sslLogCommands = findProperty("sslLogCommands") != null ?: false
    if (sslLogCommands)
        println("SHELL> ${fullCommand.join(" ")}")
}

private static String createSan(
    final String domain, final String tld, final List<String> subdomains) {

    final List<String> testSubdomains = subdomains
        .collect { it.trim() }
        .collect { subdomain ->
            [ "test", tld ].collect { "${subdomain}.${domain}.${it}" }
        }
        .flatten()
        .collect { it as String }

    final List<String> allSubdomains = testSubdomains + [ "${domain}.test", "localhost" ]
    final List<String> fullSubdomains = allSubdomains.collect { "dns:${it}".toString() }
    return fullSubdomains.join(",")
}
